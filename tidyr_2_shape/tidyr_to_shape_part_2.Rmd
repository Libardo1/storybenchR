---
title: "tidyr to shape - part 2"
author: "Martin Frigaard"
date: "8/28/2017"
output: html_document
---

## Set-up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/martinfrigaard/Dropbox/writing/storybenchR")
```


## Packages

```{r load_packages, message=FALSE, warning=FALSE}
source("load_packages.R")
```

## Data Ingestion

We are going to continue learning how to tidy data with the `drug_use` data set from the article, "How Baby Boomers Get High" available [here](http://fivethirtyeight.com/datalab/how-baby-boomers-get-high/)

### Workflow tips

We have been using the native 538 data sets in the `fivethirtyeight` package, but many times you'll be getting data from a url or web source, so I will go over some basic tips on how to do this. 

1. First, where are we putting this file? Below is a handy trick I learned from [Jeff Leek](http://jtleek.com/).

```{r create_dir}
if (!file.exists("Data")) {
     dir.create("Data")
}
```

2. Download the file from Github
```{r df_path}
# get the path to the file on Github
df_url <- "https://github.com/rudeboybert/fivethirtyeight/raw/master/data/drug_use.rda"
# download.file(df_url, "./Data/drug_use538.rda", method = "curl") # for mac
download.file(df_url, "./Data/drug_use538.rda")
# check
dir("./Data")
```

3. Load the data
```{r load}
load("./Data/drug_use.rda")
ls()
```

4. Rename the data something generic (optional)

Some people recommend renaming the data frame something generic (like `df` or `ds`), but I can't bring myself to do this. I can see the positive aspects (standardization, reusable templates, consistency, etc.). However, the projects I've worked on have involved cleaning and joining disparate data sources, and the fear of confusing two data frames forces me to use specific names for each object in my working environment. So I name the `drug_use` data frame `drug_use538` (so I can use pattern matching later, too).

```{r drug_use538}
drug_use538 <- drug_use 
drug_use538 %>% glimpse()
rm(drug_use)
```

How you name an object is important, and I recommend using `snake_case` (all lower) instead of `period.case` or `CamelCase` (periods interfere with R, Stata only takes lower-case variable names).

These guys have done a good job with both rules on this data set, so we will use the `Cushings` data frame from the `MASS` package

```{r Cushings_example}
Cushings <- MASS::Cushings %>% tbl_df()
Cushings %>% glimpse()
```

To change all the `names()` to lowercase, use the following functions:

```{r to_lower}
var_names <- Cushings %>% names()
var_names <- tolower(var_names)
names(Cushings) <- var_names
Cushings %>% glimpse()
```

Lets clear these objects.
```{r}
rm(var_names, Cushings)
ls()
```

## Data shape

The first thing we should notice is the `drug_use` data set is not tidy. What are the dimensions of this data set? Well, there are many ways to see this. The base R way is:

```{r dim_base}
dim(drug_use538)
ncol(drug_use538)
nrow(drug_use538)
```

But you get the same information from `glimpse()` so I recommend using it instead. 
```{r dimensions}
drug_use538 %>% glimpse()
```

## Identify the measures & variables 

So we have a variable for each drug ***AND*** their use, which essentially means we have two measurements per variable (violating the laws of the tidyverse). In order to tidy this data set, we need to:

1. grab the drug use variables (i.e. `ends_with("_use")`)  
2. restructure (i.e. `gather()`) them up into two new variables (`drug` and `use`)    
3. change the name of `drug` to `drug` + `whatever the drug use variable was`.   

```{r use}
use538 <- drug_use538 %>%
  dplyr::select(age, n, ends_with("_use")) %>%
  gather(drug, use, -c(age, n)) %>%
  mutate(drug = str_sub(drug, start = 1, end = -5))
use538 %>% glimpse()
```

The `str_sub` function comes from the `stringr` package. It extracts parts of a string and takes both `start` and `end` arguments (represented here with two numbers, `1` and `-5`). So the `mutate()` function says, 

"take the original `drug` variables, but only extract the letters from the start of the word, and stop five characters before the end of the word." 

Now we need to: 

1. grab the drug use variables (i.e. `ends_with("_freq")`)   
2. restructure (i.e. `gather()`) them up into two new variables (`drug` and `freq`)    
3. change (`mutate()`) the name of `drug` to `drug` + `whatever the drug freq variable was`    

```{r freq}
freq538 <- drug_use538 %>%
  dplyr::select(age, n, ends_with("_freq")) %>%
  gather(drug, freq, -c(age, n)) %>%
  mutate(drug = str_sub(drug, start = 1, end = -6))
freq538 %>% glimpse()
```


These functions are almost identical to the set we used to create the `use538` data set, the only difference being we are now shaving the `_freq` characters off the `drug` variable instead of the `_use` characters. 

## Joins

Much of the grammar in `dplyr` follows the same logic/structure of SQL, the *lingua franca* of relational databases (RDBs). One of the defining characteristics of RDBs is their ability to join tables together in a variety of ways using primary and foreign keys. 

There are three types of `joins` in the `dplyr` package. 

### the `inner_join`

If we have two tables with data in them, an `inner_join`s can be used to select only observations where the value for the common attribute (or **key**) is common in both tables.

***What is a key?*** A key is a common attribute (usually some form of `id` variable) shared by both tables. Hadley Wickham has a great visual aid for joins in the [R for Data Science book](http://r4ds.had.co.nz/relational-data.html).

I will expand a little on his example below:

```{r joins}
table_x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3",
     4, "x4")
table_y <- tribble(
  ~key, ~val_y,
     2, "y2",
     3, "y3",
     4, "y4")
```

Lets take a look at the two tibbles in my working environmett.

```{r table_x}
table_x %>% glimpse()
```


```{r table_y}
table_y %>% glimpse()
```

`table_x` is 4 x 2 (4 observations, 2 variables) and `table_y` is 3 x 2 (3 observations, 2 variables). I want to join them with an `inner_join` on `key`, but before I do, what do you think the dimensions of the new object (`table_inner_join`) will be? 

```{r table_inner_join}
table_inner_join <- inner_join(table_x, table_y, by = "key") 
table_inner_join %>% glimpse()
```

The `inner_join` matched all observations with common attributes (i.e. if it was in `table_x` and it was in `table_y`, it will be in `table_z`). I tend to think of the `inner_join` as being "completely matched". 

For example, in the `tidytext` package, `inner_join`s and `anti_join`s are used to match or exclude words by column in sentiment analysis. If we perform an `anti_join` on `table_x` and `table_y`, what do you think we will get?

```{r table_anti_join}
table_anti_join <- anti_join(table_x, table_y, by = "key") 
table_anti_join %>% glimpse()
```

The `anti_join` returns only unmatched observation from the first table (`table_x`).  

### The `left_join`

The `left_join` will return all observations from the first table (`table_x`) and the matching observations from the second (`table_y`).  

The `left_join` is the join I use the most because I am usually starting with some table (`table_x`) and then looking to add new data to it (`table_y`), but not necessarily get rid of any of the original data. 

```{r}
table_left_join <- left_join(table_x, table_y, by = "key")
table_left_join %>% glimpse()
```
As you can see, this kept all the data from the first table and added new variables and observations for the new data. 

```{r remove_tables}
# remove tables
rm(list = ls(pattern = "table"))
```

So now we know how to join the `drug_use_tidy_538` table. We want to keep all the data on drug use (`use538`) and add the data on drug frequency (`freq538`). We can do this with `left_join`.

```{r drug_use_tidy_538}
drug_use_tidy_538 <- left_join(x = use538, y = freq538, by = c("age", "n", "drug"))
drug_use_tidy_538 %>% glimpse()
```

Compare this tidy data frame to to the "un-tidy" version and read this quote from Wickham's original [paper](https://www.jstatsoft.org/article/view/v059i10) on the tidy format

>"the [tidy] layout ensures that values of different variables from the same observation are always paired."

```{r}
drug_use538 %>% glimpse()
```

You can see that the tidy format consists of fewer variables and more observations (211 observations & 5 variables vs. 17 observations and 28 variables). The R language is vector-based, so having fewer, longer variables is better than having multiple short variables. 

Also remember that tidying data refers to "structuring datasets to facilitate manipulation, visualization and modeling." These are the primary goals of any data cleaning process. 

## Data dictionary

```{r data_dictionary_pkgs}
install.packages(c("Hmisc","e1071"))
library(Hmisc)
library(e1071)
```

1. Create a data dictionary:

```{r describe}
data_dictionary <- describe(drug_use_tidy_538)
```

2. Create the `Meta` foder for your data dictionary
```{r Meta}
if (!file.exists("Meta")) {
     dir.create("Meta")
}
```


2. Save your data dictionary as a separate file to document it:
```{r sink}
sink("Meta/data_dictionary.txt", append = TRUE)
data_dictionary
sink()
dir("Meta/")
```

3. Look at your data dictionary
```{r file_show}
file.show(file = "Meta/data_dictionary.txt",pager = "internal")
```

## Clean out your working directory

So if I have followed my naming rules, I should be able to save and remove these objects easily. I want to save the tidy dataset as an `.csv` file, but first I want to see the objects in my working environment. 

```{r}
ls() %>% sort() %>% writeLines()
# put in vector
wrkng <- ls() %>% sort() 
```

I will use the `write_csv` from the `readr` package.

```{r write_csv}
write_csv(as_data_frame(drug_use_tidy_538), "./Data/drug_use_tidy_538.csv")
dir("./Data")
```

Now I can clean out everything in my `wrkng` vector. 

```{r remove_working_environment_objects}
rm(list = wrkng)
ls()
```

