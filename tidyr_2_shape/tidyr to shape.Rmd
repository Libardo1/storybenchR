---
title: "tidyr for shaping data"
author: "Martin Frigaard"
date: "5/1/2017"
output:
  html_document:
    fig_caption: yes
    highlight: tango
    theme: united
    toc: yes
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# knitr::opts_knit$set(root.dir = "/Users/martinfrigaard/Dropbox/writing/storybenchR")
knitr::opts_knit$set(root.dir = "W:\\working\\storybenchR")
```

```{r load_packages, message=FALSE, warning=FALSE}
source("load_packages.R")
```

> _this is the first in a three-part series on cleaning data to visualize it in R using the `tidyverse`_

***

# Load the packages into RStudio

First, load the `tidyverse` & `magrittr`.

```{r packages}
#suppressWarnings(suppressMessages(install.packages("tidyverse")))
suppressWarnings(suppressMessages(library(tidyverse)))
suppressWarnings(suppressMessages(library(magrittr)))
```

## *Welcome to the `tidyverse`*

The [`tidyverse`](http://tidyverse.org/) is a collection of R packages developed by RStudio's Chief Scientist [Hadley Wickham](http://hadley.nz/). These packages work well together as part of larger data analysis pipeline. To learn more about these tools and how they work together, read [R for data science](http://r4ds.had.co.nz/). 

![the tidyverse](https://github.com/mjfrigaard/my_r_projects/blob/master/storybench_R/tidyverse2.1.png?raw=true)  


### The pipe `%>%`  

The pipe makes your code read more like a sentence, branching from left to right. 

So something like this:     
`f(x)`  
becomes this:   
`x %>% f`   
And something like this:   
`h(g(f(x)))`   
becomes this:   
`x %>% f %>% g %>% h`   

The "pipe" and is from the `magrittr` package. Read about using it [*here*](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html)

***

# Part 1: Tidy data

**Tidy data** is a term that describes a standardized approach to structuring data sets to make analyses and visualizations easier. If you've worked with SQL and relational databases, you'll recognize most of these concepts. 

Hadley Wickham took a lot of the technical jargon from Edgar F. Codd's [normal form](https://en.wikipedia.org/wiki/Third_normal_form) and applied it to a single data table. More importantly, he translated these principles into terms just about anyone doing data analysis should be able to recognize and understand.

## Core tidy data principles

There are three principles for **tidy data**: 

1. Variable make up the columns  
2. Observations make up the rows  
3. Values go into cells  

*The third principle is almost a given if you've handled the first two, so we will focus on these.* 

## What is a variable?

**A variable is any measurement that can take multiple values.** 

Depending on the field a data set comes from, variables can be referred to as an independent or dependent variables, features, predictors, outcomes, targets, responses, or attributes. 

Variables can generally fit into three categories: **fixed variables** (characteristics that were known before the data were collected), **measured variables** (variables containing information captured during a study or investigation), and **derived variables** (variables that are created during the analysis process from existing variables).

#### An example: 
Suppose clinicians were testing a new anti-hypertensive drug. They recruit a 30 patients, all of whom are being treated for hypertension, and divide them randomly into three groups. The clinician gives one third of the patients the drug for eight-weeks, another third gets a placebo, and the final third gets care as usual. At the beginning of the study, the clinicians also collected information about the patients. These measurements included the patient's `sex`, `age`, `weight`, `height`, and baseline blood pressure (`pre BP`).  

For patients in this hypothetical study, the group they were randomized to (i.e the `drug`, `control`, or `placebo` group), would be considered a **fixed variable**. The measured `pre BP` (and `post BP`) would be considered the **measured variables**. 

What if after the trial was over--and all of the data were collected--the clinicians wanted a way of identifying the number of patients in the trial with a reduced blood pressure (`yes` or `no`)? One way is to create a new categorical variable that would identify the patients with `post BP` less than 140 mm Hg (`1` = `yes`, `0` = `no`). This new categorical variable would be considered a **derived variable**.  

The data for the fictional study I've described also contains an underlying dimension of time. As the description implies, each patient's blood pressure was measured before and after they took the `drug` (or `placebo`). So these data could conceivably have variables for **date of enrollment** (the date a patient entered the study), **date of pre blood pressure** measurement (baseline measurements), **date of drug delivery** (patient takes the drug), **date of post blood pressure** measurement (blood pressure measurement taken at the end of the study).

## What'a an observation? 

**Observations are the unit of analysis, or whatever the "thing" is that's being describing by the variables**. 

Sticking with our fictional blood pressure trial, the `patients` (or people) would be the unit of analysis. In a tidy data set, we would expect each row to represent a single patient. Observations are a bit like [nouns](https://en.wikipedia.org/wiki/Noun), in a sense that pinning down an exact definition can be difficult, and it often relies heavily on how the data were collected and what kind of questions you're trying to answer. Other terms for observations include records, cases, examples, instance, or samples.

## The data table

Tables are made up of `values`. And as you have probably already guessed, a `value` is the thing in a spreadsheet that isn't a `row` or a `column`. I find it helpful to think of `values` as a physical locations in a table--they are what lies at the intersection of a `variable` and an `observation`. 

For example, imagine a single number, `75`, sitting a table. 


|               | Column 1      | Column 2      |
| ------------- | ------------- | ------------- |
| Row 1         |               |               |
| Row 2         |               | `75`          |



We could say this number's location is the intersection of `Column 2` and `Row 2`, but that doesn't tell us much. The data (`75`) is meaningless sitting in a cell without any information about what it represents. A number all alone in a table begs the question, "*seventy-five what?*"  

This is why thinking of a `table` as being made of `variables` (in the columns) and `observations` (in the rows) helps get to the meaning behind the `values` in each cell. After adding `variable` (column) and `observation` (row) names, we can see that this `75` is the pre diastolic blood pressure (`Pre_Dia_BP`) for patient number 3 (`patient_3`).

|               | Col 1         |  `Pre_Dia_BP` |
| ------------- | ------------- | ------------- |
| Row 1         |               |               |
| `patient_3`   |               | `75`          |

It's also worth pointing out that this same information could be presented in another way:

|               | `meas_type`   | `Dia_BP`      |
| ------------- | ------------- | ------------- |
| Row 1         |               |               |
| `patient_3`   | `pre`         | `75`          |

This arrangement is displaying the same information (i.e. the pre diastolic blood pressure for patient number 3), but now the column `meas_type` is containing the information on *which* blood pressure measurement the `75` represents (`pre`). Which on is tidy? In order to answer this, we will build a pet example to establish some basic tidying terminology.

## The `tibble` (better than a table)

We will use the call below to create a **key-value pair** reference `tibble`. `tibble`s are an optimized way to store data when using packages from the `tidyverse`, and you should read more about them [here](http://tibble.tidyverse.org/). 

We are going to build a `tibble` from scratch, defining the columns (`variables`), rows (`observations`), and contents of each cell (`value`). By doing this, we'll be able to keep track of what happens as we rearrange these data. The goal of this brief exercise is to make `key-value` pairs easier to see and understand.

Our new object (`key_value`) is built with the following underlying logic. 

1. **Rows** are numbered with a number (`1`-`3`) and an underscore (`_`), and always appear at the front of a `value`. 
2. **Columns** are numbered with an underscore (`_`) and a number (`1`-`3`), and always appear at the end of a `value`. 


```{r}
key_value <- tribble(
     ~row, ~key1, ~key2, ~key3, # These are the names of the columns (indicated with ~)
     "1", "1_value_1","1_value_2","1_value_3", # Row 1
     "2", "2_value_1", "2_value_2", "2_value_3", # Row 2
     "3", "3_value_1", "3_value_2", "3_value_3" # Row 3
)
key_value
```

So, the **value** for `key1` and `row = 1` is `1_value_1`; The **value** for `key2` and `row = 2` is `2_value_1`; and so on. 

The first number `#_` represents the `row` (`observation`) position, the trailing number `_#` represents the `key_` column (`variable`) position. 

***

## The `tidyr` package

`tidyr` is a package from the `tidyverse` that helps you structure (or re-structure) your data so its easier to visualize and model. Here is a link to the [tidyr page](http://tidyr.tidyverse.org/). Tidying a data set usually involves some combination of either converting rows to columns (`spread`ing), or switching the columns to rows (`gather`ing).

We can use our `key_value` object to explore how these functions work.

***

### Gather

From `??tidyr::gather`:

_"Gather takes multiple columns and collapses into key-value pairs, duplicating all other columns as needed. You use `gather()` when you notice that you have columns that are not variables"_

Let's start by gathering the three `key` columns into a single column, with a new column `value` that will contain all their values.

```{r}
kv_gathered <- key_value %>% 
     gather(key, # this will be the new column for the 3 key columns
            value, # this will contain the 9 distinct values
            key1:key3, # this is the range of columns we want gathered
            na.rm = TRUE # handles missing
            )
kv_gathered
```

Notice the structure:
* The new `key` column is now `9 rows`, with the values from the three former  `key1`, `key2`, and `key3` columns.
* The `value` column contains all the content from the cells at each intersection of `row` and the `key1`, `key2`, and `key3` columns

I call this arrangement of data `"stacked"`, Wickham refers to this as `indexed`. But the important take-away is that we've used `gather()` to scoop up the data that was originally scattered across three columns and placed them into two columns: `key` and `value`.

#### Key-value pairs

Key-value pairs pair up `keys` and `values`. This means when we specified `key` as the name of the new column, the command took the three previous `key` columns and stacked them in it. Then we specified `value` as the name of the new column with their corresponding `value` pair. 

*What about the `row` column?* We left this column out of the call because we want it to stay in the same arrangement (i.e. `1`,`2`,`3`). When the `key` and `value` columns get stacked, these rows get repeated down the column,

Nothing was lost in the process, either. I can still look at `row:3,key:2` and see the resulting value `3_value_2`. 

### Spread 

Now we'll `spread` the `key` and `value` columns back into their original arrangement (three columns of `key_1`, `key_2`, & `key_3`). 

The `??tidyr::spread` description reads:

_"Spread a key-value pair across multiple columns"_ 

```{r}
kv_spreaded <- kv_gathered %>% 
     spread(
          key, 
          value
          )
kv_spreaded
```

`Spread` moved the values that were stacked in two columns (`key` and `value`) into the three distinct `key_` columns. 

```

row_    key     value
<chr>  <chr>   <chr>
1      key1   1_value_1        
2      key1   2_value_1         
3      key1   3_value_1   >>>      
                                key1      
                                1_value_1
                                2_value_1
                                3_value_1


```

The **key-value** pairs are the indexes we can use to rearrange the data to make it tidy. 

Which version of the `key_value` is tidy? We stated that tidy data means, _**"one variable per column, one observation per row"**_ , so the arrangement that satisfied this condition is the `key_gathered` data set. But I want to stress that without knowledge of what these variables and observations actually containt, we can't really know if these data are tidy. 

***

### The `fivethirtyeight` package. 

Albert Y. Kim, Chester Ismay, and Jennifer Chunn recently put together an R package with a variety of datasets from [fivethirtyeight articles](https://cran.r-project.org/web/packages/fivethirtyeight/vignettes/fivethirtyeight.html).  To explore some of the tidyr principles, we'll look at the `murder_2015_final` data set that comes with this package. 

First, load the package and the data set. These data were used for this [538 article](https://fivethirtyeight.com/features/a-handful-of-cities-are-driving-2016s-rise-in-murders/) on the cities driving up the national average. We will use this `tibble` to practice a few of the commands we've learned. 

```{r}
library(fivethirtyeight)
murder_2015_final
```

Lets gather up the two year variables, `murders_2014` & `murders_2015` into a single year column `murder_year`.  We'll store the number of murders in a column titled `murders`, and call this new object `murders_gathered`. 
```{r}
murders_gathered <- murder_2015_final %>% 
    gather(
        murder_year,
        murders,
        murders_2014:murders_2015,
        na.rm = TRUE)
murders_gathered
```

### Arrange

Now let's arrange this data aphabetically by `state` and `city`. We can do this with `arrange()` from the `dplyr` package. 

*We'll learn more about `dplyr` in the next tutorial!* 


```{r}
murders_arranged <- murders_gathered %>% 
    arrange(
        state, 
        city)
murders_arranged
```

So now we have the two years in a single column (`murder_year`), but the repeating `murder_` text is redundant. I want to get the `year` in a column by itself. 

### Separate

Now I want to put the murder years (`2014` & `2015`) back into two different columns. I'll do this with `separate()`. 

The `separate()` command uses a name of the existting column we want to separate (`murder_year`), and the names of the columns that will contain the separated values (`c("text", "year")`).
```{r}
murders_separate <- murders_arranged %>%
    separate(
        murder_year,
            into = c("text", 
                     "year")
        )
murders_separate
```

Great--now I can use `spread()` to put the `year` back into two different columns, `2014` & `2015`. But I will combine this with `arrange()` so the output is easier to read.
```{r}
murders_spread <- murders_separate %>% 
    spread(
        year,
        murders
        ) %>% 
        arrange(
            state,
            city)
murders_spread
```

What if I want to combine `city` and `state` into a single column (`city_state`)?

### Unite

The final command, `unite()`, lets me paste the contents of columns onto one another. It requires the name of the new column (`city_state`) and the columns I want to combine (`city` & `state`). But I want to sort this new tibble in descending order of `change`, and I want to remove the `text` variable. 

I can combine all of these together with the pipe (`%>%`).
```{r}
murders_final <- murders_spread %>%
unite(
    city_state, 
    city, 
    state) %>% 
        arrange(
            city_state
            ) %>% 
            select(
                -(text)
                )
murders_final
```

***

## Recap:

We used the `pipe` operator to string together various `tidyr` and `dplyr` funtions for structuring our data (in `tibble`s)
1. `gather()` collects data across columns and puts it into into rows
2. `arrange()` sorts the data in each column
3. `separate()` divides the contents of a column apart into new columns
4. `spread()` distributes data from rows into columns
5. `unite()` attaches the contents from one column onto the contents of another column 

![tidyr functions](https://github.com/mjfrigaard/my_r_projects/blob/master/storybench_R/tidyr_2_shape/tidyr.png?raw=true)


